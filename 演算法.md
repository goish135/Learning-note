### 動態規劃
1. 佛洛伊德最短路徑演算法
2. [0/1 背包問題](#2) 
### 貪婪
1. 最小生成樹<br>
1.1 **Prim** 演算法<br>
1.2 **Kruskal** 演算法
2. 單一起點最短路徑問題 **Dijkstra** 演算法 
### 回溯
1. **8皇后問題**
### 搜尋
1. **DFS**
2. **BFS**

<h4 id="2">0/1背包問題</h4>

[參考網址](https://openhome.cc/Gossip/AlgorithmGossip/KnapsackProblem.htm)

設有ABCDE五種水果，要放入負重為8kg的背包，求該放進哪些水果可得最佳解?

| index | 種類 | 公斤 | 價格 |
| - | - | - | - |
| 0 | A | 4kg | 4500 |
| 1 | B | 5kg | 5700 |
| 2 | C | 2kg | 2250 |
| 3 | D | 1kg | 1100 |
| 4 | E | 6kg | 6700 |

sol:<br>
一個元素一個元素依序放入A->B->C->D->E,並假設有1~8kg的背包8個<br>
求各階段(放入第?th個水果時，各個負重量)的最佳解。<br>
value[8+1]: 紀錄各負重的價值，items[8+1]:紀錄各負重最後放進水果的index <br>
```C++
#include <stdio.h> 
#include <stdlib.h> 
#define LIMIT 8   // 重量限制 

typedef struct { 
    char name[20]; 
    int weight; 
    int price; 
} Fruit; 

void knapsack(Fruit*, int*, int*, int, int);
int min(Fruit*, int);

int main(void) { 
    Fruit fruits[] = {
                      {"李子", 4, 4500},
                      {"蘋果", 5, 5700},
                      {"橘子", 2, 2250},
                      {"草莓", 1, 1100},
                      {"甜瓜", 6, 6700}
                     };
    int items[LIMIT + 1] = {0}; 
    int values[LIMIT + 1] = {0};  
    
    int length = sizeof(fruits) / sizeof(fruits[0]);
    knapsack(fruits, values, items, length, LIMIT);

    printf("物品\t價格\n"); 
    int i;
    // min(fruits, length) :最輕的水果 
    for(i = LIMIT; i >= min(fruits,length) ; i -= fruits[items[i]].weight) {
        printf("%s\t%d\n", fruits[items[i]].name, fruits[items[i]].price); 
    } 
    printf("合計\t%d\n", values[LIMIT]); 

    return 0; 
}  

void knapsack(Fruit* fruits, int* values, int* items, 
              int length, int limit) {
    int i, w;
    for(i = 0; i < length; i++) { 
        for(w = fruits[i].weight; w <= limit; w++) {
            int p = w - fruits[i].weight;
            int newValue = values[p] + fruits[i].price; 
            if(newValue > values[w]) {   // 找到階段最佳解 
                values[w] = newValue; 
                items[w] = i; 
            }
        } 
    }
}

int min(Fruit* fruits, int length) {
    int i, m;
    for(i = 0, m = fruits[0].weight; i < length; i++) {
        if(fruits[i].weight < m) {
            m = fruits[i].weight;
        }
    }
    return m;
} 
```
**[類題]** [2015NCPC](http://ncpc.nsysu.edu.tw/ezfiles/351/1351/img/2603/NCPC2015R1.pdf) <br>
__Problem E__








































[#1]: here
